# (№ 2419) Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
# Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч три
# камня или увеличить количество камней в куче в два раза. Чтобы делать ходы, у каждого игрока есть
# неограниченное количество камней. Игра завершается в тот момент, когда суммарное количество камней
# в кучах становится не менее 62. Победителем считается игрок, сделавший последний ход, т. е. первым
# получивший позицию, в которой в кучах будет 62 или больше камней.
# В начальный момент в первой куче было 7 камней, во второй куче – S камней, 1 ≤ S ≤ 54. Будем говорить,
# что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
# Ответьте на следующие вопросы:
#   Вопрос 1. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Назовите
#   минимальное значение S, при котором это возможно.
#   Вопрос 2. Укажите минимальное значение S, при котором у Пети есть выигрышная стратегия, причём Петя не
#   может выиграть первым ходом, но может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
#   Вопрос 3. Найдите два значения S, при которых у Вани есть выигрышная стратегия, позволяющая ему выиграть
#   первым или вторым ходом при любой игре Пети, и при этом у Вани нет стратегии, которая позволит ему гарантированно
#   выиграть первым ходом. Найденные значения запишите в ответе в порядке возрастания.

from functools import lru_cache

def moves(h):
    a,b=h
    return (a+3,b),(a,b+3),(a*2,b),(a,b*2)
@lru_cache(None)
def f(h):
    if sum(h)>=62:
        return 'СР'
    elif any(f(m)=='СР' for m in moves(h)):
        return 'П1'
    elif all(f(m)=='П1' for m in moves(h)):
        return 'В1'
    elif any(f(m)=='В1' for m in moves(h)):
        return 'П2'
    elif all(f(m)=='П1' or f(m)=='П2' for m in moves(h)):
        return 'П2'
for s in range(1,60):
    print(s,f((7,s)))