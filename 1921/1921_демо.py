# демо-2021). Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
# Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну из куч
# (по своему выбору) один камень или увеличить количество камней в куче в два раза. Игра завершается
# в тот момент, когда суммарное количество камней в кучах становится не менее 77. Победителем считается
# игрок, сделавший последний ход, т.е. первым получивший такую позицию, при которой в кучах будет 77 или
# больше камней. В начальный момент в первой куче было семь камней, во второй куче – S камней; 1 ≤ S ≤ 69.
# Задание 19.
# Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. Укажите минимальное значение
# S, когда такая ситуация возможна.
# Задание 20.
# Найдите два таких значения S, при которых у Пети есть выигрышная стратегия, причём одновременно
# выполняются два условия:
# − Петя не может выиграть за один ход;
# − Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
# Найденные значения запишите в ответе в порядке возрастания.
# Задание 21
# Найдите минимальное значение S, при котором одновременно выполняются два условия:
# – у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# – у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

from functools import lru_cache

def moves(h):
    a,b=h
    return (a+1,b),(a,b+1),(a*2,b),(a,b*2)
@lru_cache(None)
def f(h):
    if sum(h)>=77:
        return 'СР'
    elif any(f(m)=='СР' for m in moves(h)):
        return 'П1'
    elif all(f(m)=='П1' for m in moves(h)):
        return 'В1'
    elif any(f(m)=='В1' for m in moves(h)):
        return 'П2'
    elif all(f(m)=='П1' or f(m)=='П2' for m in moves(h)):
        return 'В2'

for s in range(1,80):
    print(s,f((7,s)))

# 19) 18
# 20) 31 34
# 21) 30